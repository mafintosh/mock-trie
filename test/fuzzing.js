const test = require('tape')
const SandboxPath = require('sandbox-path')
const FuzzBuzz = require('fuzzbuzz')

const Trie = require('../trie')
const ReferenceTrie = require('./helpers/reference')
const path = new SandboxPath('/')

const KEY_CHARACTERS = 'abcd'
const VALUE_CHARACTERS = 'abcdefghijklmnopqrstuvwxyz'

class TrieFuzzer extends FuzzBuzz {
  constructor (opts) {
    super(opts)

    this.trie = new Trie()
    this.reference = new ReferenceTrie(this.randomInt.bind(this))
    this._maxComponentLength = opts.maxComponentLength || 10
    this._maxPathDepth = opts.maxPathDepth || 10
    this._syntheticKeys = opts.syntheticKeys || 0

    // TODO: Hack for simple code generation.
    this._trace = [
      'const trie = new Trie()',
      ''
    ]

    this.add(2, this.putNormalValue)
    this.add(1, this.createSymlink)
    // this.add(1, this.rename)
    // this.add(1, this.delete)
  }

  _generatePair () {
    const generator = this.randomInt.bind(this)
    const depth = this.randomInt(this._maxPathDepth) || 1
    const value = randomString(VALUE_CHARACTERS, generator, 10)
    const path = new Array(depth).fill(0).map(() => {
      const length = this.randomInt(this._maxComponentLength) || 1
      return randomString(KEY_CHARACTERS, generator, length)
    })
    return { path, value }
  }

  async putNormalValue () {
    const { path, value } = this._generatePair()
    const key = path.join('/')
    this.debug('putting normal key/value:', key, '->', value)
    await this.trie.put(key, value)
    this._trace.push(`await trie.put(\'${key}\', \'${value}\')`)
    this.reference.put(path, value)
  }

  async createSymlink () {
    const { path: linknamePath } = this._generatePair()
    const { path: targetPath } = this._generatePair()
    const linkname = linknamePath.join('/')
    const target = targetPath.join('/')

    // Do not create circular symlinks
    if (linkname.startsWith(target) || target.startsWith(linkname)) return

    this.debug('creating symlink:', linkname, '->', target)
    await this.trie.symlink(target, linkname)
    this._trace.push(`await trie.symlink(\'${target}\', \'${linkname}\')`)
    this.reference.symlink(targetPath, linknamePath)
  }

  async rename () {
    const { path: toPath } = this._generatePair()
    const { path: fromPath } = this._generatePair()
    const to = toPath.join('/')
    const from = fromPath.join('/')

    this.debug('renaming:', from, '->', to)
    await this.trie.rename(from, to)

    // this.trace('await trie.rename(%o, %o)', from, to)
    this._trace.push(`await trie.rename(\'${from}\', \'${to}\')`)

    this.reference.rename(fromPath, toPath)
  }

  async delete () {
    const { path } = this._generatePair()
    const key = path.join('/')

    this.debug('deleting:', key)
    await this.trie.del(key)

    // this.trace('await trie.rename(%o, %o)', from, to)
    this._trace.push(`await trie.del(\'${key}\')`)

    this.reference.delete(path)
  }

  async _validateWithSyntheticKeys (other) {
    for (let i = 0; i < this._syntheticKeys; i++) {
      const { path } = this._generatePair()
      await this.reference.validatePath(path, other)
    }
  }

  async _validate () {
    this.debug('validating against reference:\n', await this.reference.print())
    try {
      await this.reference.validateAllReachable(this.trie)
      await this._validateWithSyntheticKeys(this.trie)
    } catch (err) {
      if (!err.mismatch) throw err
      const { key, value, expectedKey, expectedValue } = err.mismatch
      this._trace.push(...[
        '',
        `// Should return ${expectedKey} -> ${expectedValue}`,
        `// Actually returns ${key} -> ${value}`,
        `const node = await trie.get('${key}')`,
        `const value = (node && node.value) ? node.value.value : null`,
        `t.same(value, ${expectedValue ? `'${expectedValue}'` : null})`,
        `t.end()`
      ])
      const requires = 'const test = require(\'tape\')\nconst Trie = require(\'../trie\')\n\n'
      const testCase = `${requires}test(\'failing autogenerated test case\', async t => {\n  ${this._trace.join('\n  ')} \n})`
      err.testCase = testCase
      throw err
    }
  }
}

function run (numTests, numOperations) {
  test(`${numTests} runs with ${numOperations} fuzz operations each`, async t => {
    var error = null
    try {
      for (let i = 0; i < numTests; i++) {
        const fuzz = new TrieFuzzer({
          seed: `hypertrie-${i}`,
          debugging: true,
          maxComponentLength: 5,
          maxPathDepth: 3,
          syntheticKeys: 500
        })
        await fuzz.run(numOperations)
      }
    } catch (err) {
      error = err
      t.fail(error)
      if (error.testCase) {
        console.error('Failing Test:\n')
        console.error(error.testCase)
        console.error()
      }
    }
    if (error) t.fail('fuzzing failed')
    else t.pass('fuzzing succeeded')
    t.end()
  })
}

run(1000, 5)

function randomString (alphabet, generator, length) {
  var s = ''
  for (let i = 0; i < length; i++) {
    s += alphabet[generator(alphabet.length) || 1]
  }
  return s
}
